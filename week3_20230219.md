# Kotlin in Action 스터디 3주차 🔥
### 2023-02-19(일)

---

스터디를 진행하며 짧은 시간안에 많은 양의 내용을 정리하는 것에 대해 논의한 결과, 자신이 의미 있게 읽었던 부분이나 자세히 기록하고 싶은 내용을 정리하자는 결론이 나왔다. 

그래서 앞으로의 정리는 모든 부분이 아닌 개인적으로 잘 써먹겠다 싶은 내용 위주로 정리하려한다!😋

## 5. 람다로 프로그래밍
### 5.3 지연 계산 컬렉션 연산
`map` 이나 `filter` 컬렉션 함수를 사용하면 결과 컬랙션을 즉시 생성한다. 이는 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다는 것을 의미한다.

시퀀스를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다.

다음 예시를 보자.

```kotlin
people.map(Person::name).filter { it.startWith("A") }
```
이 경우 리스트의 크기가 작다면 문제가 없겠지만 50만개의 리스트를 작업한다면 연쇄 호출로 50만개의 리스트를 만든다는 의미이다.

효율이 매우 떨어지므로 효율적으로 작업하려면 연산이 컬렉션을 직접 사용하는 대신 시퀀스를 사용하게 만들어야 한다.

```kotlin
people.asSequnce() // 원본 컬렉션을 시퀀스로 변환
   .map(Person::name)
   .filter{ it.startWith("A") }
   .toList() // 결과 시퀀스를 리스트로 변환
```

이 뿐만 아니라 시퀀스를 사용하면 지연 계산으로 인해 원소 중 일부의 계산은 이루어 지지 않는다.

```kotlin
listOf(1, 2, 3, 4).asSequence().map { it * it }.find { it > 3 })
```

위 코드에서는 지연 계산으로 모든 원소에 대해 `map` 처리 되지 않고 최종연산인 `find` 함수 값의 리턴이 충족할 때 까지만 연산을 진행한다!

그 결과 시퀀스가 없는 환경이라면 

[1, 2, 3, 4] -> [1, 4, 9, 16] -> 4 값이 도출되지만
[1, 2, 3, 4] -> [1, 4] -> 4 값이 도출된다. (9와 16은 연산되지 않고 끝난다)

추가로 `map`과 `filter`를 같이 쓸때 순서에 따라 결과는 동일하지만 `filter`를 먼저 써준다면 조건에 맞지 않는 원소를 제외하고 넘기기 때문에 연산 횟수를 줄일 수 있다.

> 5장 후기
> 
>5장에서는 그밖에도 람다식에서 `it.age` 말고도 다른 표현방법식을 설명하였고 평소 유용하게 쓰던 `with`, `apply` 등을 설명하고 있다. 크게 어려운 부분 없이 내용을 상기시키며 진행했다.

---

## 6. 코틀린 타입 시스템

### 1. `let` 메소드를 이용한 널러블 변수에 대한 조건 처리

코틀린은 자바와 달리 기본적으로 널러블하지 않다. 변수를 선언 시 널이 될 수 있다는 점을 명시해주어야 한다.
 
```kotlin
fun sendEmaulTo(email: String){ ... }

val email: String? = ...
```

이메일을 보내는 메소드와 널러블 변수가 있다고 가정해볼 때

```kotlin
if(email != null) sendEmailTo(email)
```

인자를 넘기기 전에 주어진 값이 널인지 검사해야하므로 이런식으로 조건문을 이용할 수 있지만 코틀린에선

```kotlin
email?.let { sendEmailTo(email) }  
```

`let` 메소드를 이용해 간단히 처리할 수 있다.

### 2. Nothing 타입
코틀린에선 성공적으로 값을 돌려주는 일이 없는 경우 반환 값이라는 개념이 의미없는 함수에 사용할 수 있는 쓸 수 있다.

`Nothing` 타입을 사용하여 코드를 분석하는 개발자가 해당 함수는 정상적으로 끝나지 않는 다라는 사실을 알려줄 수 있다.
```kotlin
fun fail(msg: String): Nothing {
    throw IllegalStateException(msg)
}

val address = company.address ?: fail("No address")
```

> 6장 후기
> 
> 6장에서는 널러블에 대한 이야기와 널러블한 타입에 대한 처리들(안전한 호출, 엘비스 연산자.. )에 대해 설명하고 있다. 
> 
> 그 밖에도 컬렉션 타입을 선택하는 몇 가지 경우 컬렉션 자체의 널 여부, 원소의 널 등의 상황을 예로들며 설명했다. 자바에서 코틀린으로 넘어오며 코틀린 타입에 대해 공부해온 내용을 다시 복습하는 차원으로 공부하였다.